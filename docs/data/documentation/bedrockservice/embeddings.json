{"hierarchy":{"paths":[["doc:\/\/BedrockService\/documentation\/BedrockService"]]},"variants":[{"paths":["\/documentation\/bedrockservice\/embeddings"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/BedrockService\/documentation\/BedrockService\/Embeddings"},"sections":[],"seeAlsoSections":[{"anchor":"Related-Documentation","identifiers":["doc:\/\/BedrockService\/documentation\/BedrockService\/TextGeneration","doc:\/\/BedrockService\/documentation\/BedrockService\/Converse"],"title":"Related Documentation"},{"title":"Core Features","identifiers":["doc:\/\/BedrockService\/documentation\/BedrockService\/Converse","doc:\/\/BedrockService\/documentation\/BedrockService\/ImageGeneration","doc:\/\/BedrockService\/documentation\/BedrockService\/TextGeneration"],"generated":true,"anchor":"Core-Features"}],"metadata":{"title":"Embeddings","roleHeading":"Article","role":"article","modules":[{"name":"BedrockService"}]},"kind":"article","schemaVersion":{"patch":0,"major":0,"minor":3},"abstract":[{"type":"text","text":"Generate vector embeddings for semantic analysis"}],"primaryContentSections":[{"content":[{"type":"heading","text":"Overview","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"text":"Embeddings convert text into numerical vector representations that capture semantic meaning. These vectors enable similarity comparisons, clustering, and retrieval-augmented generation (RAG) systems.","type":"text"}]},{"type":"heading","text":"Basic Embeddings","anchor":"Basic-Embeddings","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Generate embeddings from text:"}]},{"type":"codeListing","syntax":"swift","code":["let model: BedrockModel = .titan_embed_text_v2","","guard model.hasEmbeddingsModality() else {","    throw MyError.incorrectModality(\"\\(model.name) does not support embeddings\")","}","","let embeddings = try await bedrock.embed(","    \"Swift is a powerful programming language\",","    with: model",")","","print(\"Generated embeddings with \\(embeddings.count) dimensions\")","print(\"First few values: \\(Array(embeddings.prefix(5)))\")"]},{"type":"heading","text":"Vector Size Control","anchor":"Vector-Size-Control","level":2},{"type":"paragraph","inlineContent":[{"text":"Specify the embedding vector size:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let embeddings = try await bedrock.embed(","    \"Machine learning and artificial intelligence\",","    with: model,","    vectorSize: 512",")","","print(\"Embedding dimensions: \\(embeddings.count)\")"]},{"type":"heading","level":2,"anchor":"Semantic-Similarity","text":"Semantic Similarity"},{"type":"paragraph","inlineContent":[{"text":"Compare text similarity using embeddings:","type":"text"}]},{"type":"codeListing","code":["let text1 = \"The cat sat on the mat\"","let text2 = \"A feline rested on the rug\"","let text3 = \"Quantum computing uses qubits\"","","let embedding1 = try await bedrock.embed(text1, with: model)","let embedding2 = try await bedrock.embed(text2, with: model)","let embedding3 = try await bedrock.embed(text3, with: model)","","\/\/ Calculate cosine similarity","func cosineSimilarity(_ a: [Double], _ b: [Double]) -> Double {","    let dotProduct = zip(a, b).map(*).reduce(0, +)","    let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))","    let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))","    return dotProduct \/ (magnitudeA * magnitudeB)","}","","let similarity12 = cosineSimilarity(embedding1, embedding2)","let similarity13 = cosineSimilarity(embedding1, embedding3)","","print(\"Similarity between text1 and text2: \\(similarity12)\")","print(\"Similarity between text1 and text3: \\(similarity13)\")","\/\/ text1 and text2 should have higher similarity than text1 and text3"],"syntax":"swift"},{"level":2,"anchor":"Batch-Processing","text":"Batch Processing","type":"heading"},{"inlineContent":[{"text":"Process multiple texts efficiently:","type":"text"}],"type":"paragraph"},{"code":["let texts = [","    \"Apple is a technology company\",","    \"Bananas are yellow fruits\", ","    \"Microsoft develops software\",","    \"Oranges are citrus fruits\",","    \"Google creates search engines\"","]","","var embeddings: [[Double]] = []","","for text in texts {","    let embedding = try await bedrock.embed(text, with: model)","    embeddings.append(embedding)","}","","\/\/ Find most similar texts","func findMostSimilar(to queryIndex: Int, in embeddings: [[Double]]) -> Int {","    var maxSimilarity = -1.0","    var mostSimilarIndex = 0","    ","    for (index, embedding) in embeddings.enumerated() {","        guard index != queryIndex else { continue }","        ","        let similarity = cosineSimilarity(embeddings[queryIndex], embedding)","        if similarity > maxSimilarity {","            maxSimilarity = similarity","            mostSimilarIndex = index","        }","    }","    ","    return mostSimilarIndex","}","","let queryIndex = 0 \/\/ \"Apple is a technology company\"","let similarIndex = findMostSimilar(to: queryIndex, in: embeddings)","print(\"Most similar to '\\(texts[queryIndex])': '\\(texts[similarIndex])'\")"],"syntax":"swift","type":"codeListing"},{"anchor":"Document-Retrieval-System","level":2,"text":"Document Retrieval System","type":"heading"},{"inlineContent":[{"type":"text","text":"Build a simple RAG system:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct Document {","    let id: String","    let content: String","    let embedding: [Double]","}","","class DocumentStore {","    private var documents: [Document] = []","    private let bedrock: BedrockService","    private let model: BedrockModel","    ","    init(bedrock: BedrockService, model: BedrockModel) {","        self.bedrock = bedrock","        self.model = model","    }","    ","    func addDocument(_ content: String, id: String) async throws {","        let embedding = try await bedrock.embed(content, with: model)","        let document = Document(id: id, content: content, embedding: embedding)","        documents.append(document)","    }","    ","    func search(_ query: String, topK: Int = 3) async throws -> [Document] {","        let queryEmbedding = try await bedrock.embed(query, with: model)","        ","        let similarities = documents.map { doc in","            (doc, cosineSimilarity(queryEmbedding, doc.embedding))","        }","        ","        return similarities","            .sorted { $0.1 > $1.1 }","            .prefix(topK)","            .map { $0.0 }","    }","}","","\/\/ Usage","let store = DocumentStore(bedrock: bedrock, model: model)","","try await store.addDocument(\"Swift is a programming language developed by Apple\", id: \"doc1\")","try await store.addDocument(\"Python is popular for data science and machine learning\", id: \"doc2\")","try await store.addDocument(\"JavaScript runs in web browsers and Node.js\", id: \"doc3\")","","let results = try await store.search(\"Apple programming language\")","for doc in results {","    print(\"Found: \\(doc.content)\")","}"]},{"anchor":"Text-Clustering","level":2,"text":"Text Clustering","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Group similar texts using embeddings:"}]},{"code":["struct TextCluster {","    let centroid: [Double]","    var texts: [String]","    var embeddings: [[Double]]","}","","func kMeansClustering(texts: [String], embeddings: [[Double]], k: Int, iterations: Int = 10) -> [TextCluster] {","    \/\/ Simple k-means implementation","    var clusters = Array(0..<k).map { _ in","        TextCluster(","            centroid: embeddings.randomElement()!,","            texts: [],","            embeddings: []","        )","    }","    ","    for _ in 0..<iterations {","        \/\/ Clear clusters","        for i in 0..<clusters.count {","            clusters[i].texts.removeAll()","            clusters[i].embeddings.removeAll()","        }","        ","        \/\/ Assign texts to nearest cluster","        for (textIndex, embedding) in embeddings.enumerated() {","            var minDistance = Double.infinity","            var nearestCluster = 0","            ","            for (clusterIndex, cluster) in clusters.enumerated() {","                let distance = 1.0 - cosineSimilarity(embedding, cluster.centroid)","                if distance < minDistance {","                    minDistance = distance","                    nearestCluster = clusterIndex","                }","            }","            ","            clusters[nearestCluster].texts.append(texts[textIndex])","            clusters[nearestCluster].embeddings.append(embedding)","        }","        ","        \/\/ Update centroids","        for i in 0..<clusters.count {","            if !clusters[i].embeddings.isEmpty {","                let dimensions = clusters[i].embeddings[0].count","                var newCentroid = Array(repeating: 0.0, count: dimensions)","                ","                for embedding in clusters[i].embeddings {","                    for j in 0..<dimensions {","                        newCentroid[j] += embedding[j]","                    }","                }","                ","                for j in 0..<dimensions {","                    newCentroid[j] \/= Double(clusters[i].embeddings.count)","                }","                ","                clusters[i] = TextCluster(","                    centroid: newCentroid,","                    texts: clusters[i].texts,","                    embeddings: clusters[i].embeddings","                )","            }","        }","    }","    ","    return clusters","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Model-Capabilities","level":2,"text":"Model Capabilities","type":"heading"},{"inlineContent":[{"text":"Check embedding model features:","type":"text"}],"type":"paragraph"},{"code":["if let embeddingModality = model.modality as? EmbeddingsModality {","    let params = embeddingModality.getEmbeddingsParameters()","    ","    if let vectorSizes = params.vectorSize.allowedValues {","        print(\"Supported vector sizes: \\(vectorSizes)\")","    }","    ","    print(\"Default vector size: \\(params.vectorSize.defaultValue)\")","}"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Use Cases","type":"heading","anchor":"Use-Cases"},{"type":"paragraph","inlineContent":[{"text":"Embeddings are useful for:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Semantic Search","type":"text"}],"type":"strong"},{"text":": Find documents similar to a query","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Recommendation Systems"}]},{"type":"text","text":": Suggest similar content"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Text Classification","type":"text"}]},{"type":"text","text":": Group texts by topic"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Duplicate Detection","type":"text"}]},{"type":"text","text":": Find similar or duplicate content"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"RAG Systems","type":"text"}]},{"text":": Retrieve relevant context for generation","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Clustering","type":"text"}],"type":"strong"},{"type":"text","text":": Organize large text collections"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Anomaly Detection"}]},{"text":": Identify unusual text patterns","type":"text"}],"type":"paragraph"}]}]}],"kind":"content"}],"references":{"doc://BedrockService/documentation/BedrockService":{"kind":"symbol","type":"topic","url":"\/documentation\/bedrockservice","abstract":[{"text":"A Swift library for interacting with Amazon Bedrock foundation models","type":"text"}],"role":"collection","title":"BedrockService","identifier":"doc:\/\/BedrockService\/documentation\/BedrockService","images":[{"type":"icon","identifier":"bedrock.png"}]},"doc://BedrockService/documentation/BedrockService/ImageGeneration":{"type":"topic","url":"\/documentation\/bedrockservice\/imagegeneration","kind":"article","abstract":[{"text":"Create and modify images with foundation models","type":"text"}],"role":"article","title":"Image Generation","identifier":"doc:\/\/BedrockService\/documentation\/BedrockService\/ImageGeneration"},"bedrock.png":{"variants":[{"traits":["1x","light"],"url":"\/images\/BedrockService\/bedrock.png"}],"type":"image","identifier":"bedrock.png","alt":"BedrockService"},"doc://BedrockService/documentation/BedrockService/Converse":{"title":"Converse API","url":"\/documentation\/bedrockservice\/converse","identifier":"doc:\/\/BedrockService\/documentation\/BedrockService\/Converse","type":"topic","role":"article","kind":"article","abstract":[{"text":"Build conversational AI applications with the Converse API","type":"text"}]},"doc://BedrockService/documentation/BedrockService/TextGeneration":{"type":"topic","kind":"article","url":"\/documentation\/bedrockservice\/textgeneration","abstract":[{"type":"text","text":"Generate text using the InvokeModel API"}],"role":"article","title":"Text Generation","identifier":"doc:\/\/BedrockService\/documentation\/BedrockService\/TextGeneration"}}}